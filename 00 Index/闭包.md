## 定义

一个函数和词法环境的引用捆绑在一起，这样的组合就是闭包（closure）

场景： 一般是一个函数A，return 内部的函数B，B还能访问A函数内部的变量，形成了一个B函数的变量背包；A函数执行完后，这个变量背包就不会被销毁；

## 形成条件

作用域链，当前作用域可以访问上级作用域中的变量

## 带来问题

由于垃圾回收器不会将闭包中变量销毁，于是就造成了内存泄露，内存泄露积累多了就容易导致内存溢出

## 应用

模仿块级作用域，能够**实现柯里化**，在构造函数中定义特权方法

好处
 - 存储，避免了使用全局变量，造成全局变量污染
 - 这种方法来创建私有变量、私有函数
 - 延长变量的生命周期


## 关联问题

## 作用域、执行上下文、词法环境

### 执行上下文（创建、执行、回收）

- **全局执行上下文**： 创建一个全局的 `window`对象；设置 `this` 的值等于这个全局对象。
- **函数执行上下文**： 每当一个函数被调用时, 都会为该函数创建一个新的执行上下文。
- **Eval 函数执行上下文**：  执行在 `eval` 函数内部的代码也会有它属于自己的执行上下文
最后执行上下文出栈等待虚拟机回收执行上下文

### 执行上下文栈

也称**调用栈**、**执行栈**， 拥有 `LIFO`（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。


### 词法环境

- **全局环境**： 是没有外部环境引用的词法环境 外部都是null
- **函数环境**中： 函数内部用户定义的变量存储在**环境记录器**中，并且引用的外部环境可能是全局环境，或者任何包含此内部函数的外部函数。
词法环境内部组件

- 环境记录器： 变量
- **外部环境的引用**： 意味着它可以访问其父级词法环境

```JSX
GlobalExectionContext = {        // 全局执行上下文
    LexicalEnvironment: {        // 词法环境
        EnvironmentRecord: {     // 环境记录器：存储变量和函数声明的实际位置
            Type: "Object",      
            // 在这里绑定标识符  
        }
        outer: <null>           // 对外部环境的引用：可以访问其父级词法环境
    }
}

FunctionExectionContext = {     // 函数执行上下文
    LexicalEnvironment: {
        EnvironmentRecord: {
            Type: "Declarative",
            // 在这里绑定标识符
        }
        outer: <Global or outer function environment reference>
    }
    VariableEnvironment: { // 变量环境 
		    EnvironmentRecord: { Type: "Declarative", // 在这里绑定标识符 
		    g: undefined // var声明的变量 
	    }, outer: <GlobalLexicalEnvironment> 
    }
}
```

### 变量环境

存储var变量声明


最后的最后，简要概况一下`作用域`，`词法环境`，`执行上下文`这三者的概念：

-   **作用域**：作用域就是一个独立的区域，它可以让变量不会向外暴露出去。作用域最大的用处就是隔离变量。内层作用域可以访问外层作用域。一个作用域下可能包含若干个执行上下文。
-   **词法环境**：指相应代码块内标识符与变量值、函数值之间的关联关系的一种体现。词环境内部包含环境记录器和对外部环境的引用。环境记录器是存储变量和函数声明的实际位置，对外部环境的引用意味着可以访问父级词法环境。
-   **执行上下文**：JavaScript代码运行的环境。分为全局执行上下文，函数执行上下文和eval函数执行上下文（前两个较常见）。创建执行上下文时会进行this绑定、创建词法环境和变量环境。

[引用文章](https://juejin.cn/post/7043408377661095967)