## 关键词

栈垃圾回收、堆垃圾回收、新生区老生区、Scavenge算法、标记-清除算法、标记-整理算法、全停顿、增量标记

## 定义
浏览器垃圾回收机制根据数据的存储方式分为栈垃圾回收和堆垃圾回收。
- 栈垃圾回收：一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文
-  堆垃圾回收：存在存储在堆空间-垃圾回收器回收
## 垃圾回收算法

从根节点出发，遍历所有对象，如果是不可达的，就被回收掉，这里引出一个概念-**内存碎片**

- 全局变量window
- 文档DOM树
- 存放在栈上的变量

## 分代收集

### 数据
- 长久对象
- 临时对象
### 生命周期（新生代和老生代）
- 长久周期windows、DOM---主垃圾回收器（标记-清除算法）
- 短周期函数内部变量、块级作用域变量---副垃圾回收器（Scavenge算法）

### 主垃圾回收器
运用了**可达性**回收算法--标记清除算法

### 副垃圾回收器
负责临时对象的垃圾回收，只支持1-8M容量，分为两个区域**对象区域**和**空闲区域**
#### 清理过程
- 把对象区域的所有对象标记
- 把标记可达的对象复制到空闲区域，并且有序的排列起来
- 对象区域和空闲区域对调

## 增量回收
### 背景
因为回收过程会中断js线程，导致页面卡顿
### 定义
所有垃圾回收工作被分成更小的快，每次处理一部分，多次处理，避免长时间的停顿--**全停顿**，所有用到**增量标记（Incremental Marking）算法**

## 闲时收集

垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响

## 内存泄露

_用不到的变量，不能被垃圾回收机制回收，依然占据着内存空间_

如下场景
- -   监听在`window/body`事件没有解绑
- -   互相引用
- -   定时器
- 滥用闭包
- -   数组复用：arr.length = 0
- -   对象复用：t = null

### 标记整理算法

执行标记 - 清除算法后，会产生大量不连续的内存碎片。

- 标记： 和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。
- 整理：让所有存活的对象都向内存的一端移动
- 清除： 清理掉端边界以外的内存
[参考地址](https://blog.csdn.net/yingmd2020/article/details/117928175)