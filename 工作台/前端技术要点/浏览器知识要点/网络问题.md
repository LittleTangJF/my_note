[参考地址](https://juejin.cn/post/7128205011019890695#heading-9)
## 常见的竞态问题

1. 什么是竟态
2. 通常出现的场景
3. 解决方案有哪些

## 什么是竟态

无法保证异步操作的完成会按照他们开始时同样的顺序(网络的不稳定性)

## 出现场景

搜索，分页，选项卡等切换，比如：

-   有一个分页列表，快速地切换第二页，第三页；
-   先后请求 data2 与 data3，分页器显示当前在第三页，并且进入 loading；
-   但由于网络的不确定性，先发出的请求不一定先响应，所以有可能 data3 比 data2 先返回；
-   在 data2 最终返回后，分页器指示当前在第三页，但展示的是第二页的数据。

## 解决方法

### 取消请求

1. 取消请求（xhr.abort, new AbortController(), source.cancel()）
### 注意
#### 旧版axios
在 cancel 时，axios 会在内部调用 promise.reject() 与 xhr.abort()。
```js
axios.get('/xxx', {
  cancelToken: source.token
}).catch(function(err) { 
  if (axios.isCancel(err)) {
    console.log('Request canceled', err.message);
  } else {
    // 处理错误
  }
});
```
所以我们在处理请求错误时，需要判断 error 是否是 cancel 导致的，避免与常规错误一起处理。
#### 新版axios
从 `v0.22.0` 开始，axios 支持以 fetch API 方式的 AbortController 取消请求
```js
const controller = new AbortController();

axios.get('/xxx', {
  signal: controller.signal
}).then(function(response) {
   //...
});

controller.abort() // 取消请求
```

### 可取消的 promise

的 promise，它的 resolve/reject 只能在 new Promise 内部调用，而指令式 promise 支持在 promise 外部手动调用 resolve/reject 等指令。

```js
import { createImperativePromise } from 'awesome-imperative-promise';

const { resolve, reject, cancel } = createImperativePromise(promise);

resolve("some value");
// or
reject(new Error());
// or
cancel();
```

[外部调用源码](https://github.com/slorber/awesome-only-resolves-last-promise/tree/master/src)
```js
function onlyResolvesLast(fn) {
  // 保存上一个请求的 cancel 方法
  let cancelPrevious = null; 

  const wrappedFn = (...args) => {
    // 当前请求执行前，先 cancel 上一个请求
    cancelPrevious && cancelPrevious();
    // 执行当前请求
    const result = fn.apply(this, args); 
    
    // 创建指令式的 promise，暴露 cancel 方法并保存
    const { promise, cancel } = createImperativePromise(result);
    cancelPrevious = cancel;
    
    return promise;
  };

  return wrappedFn;
}
```

### 用id保存

```js
function onlyResolvesLast(fn) {
  // 利用闭包保存最新的请求 id
  let id = 0;
  
  const wrappedFn = (...args) => {
    // 发起请求前，生成新的 id 并保存
    const fetchId = id + 1;
    id = fetchId;
    
    // 执行请求
    const result = fn.apply(this, args);
    
    return new Promise((resolve, reject) => {
      // result 可能不是 promise，需要包装成 promise
      Promise.resolve(result).then((value) => {
        // 只处理最新一次请求
        if (fetchId === id) { 
          resolve(value);
        }
      }, (error) => {
        // 只处理最新一次请求
        if (fetchId === id) {
          reject(error);
        }
      });
    })
  };
  
  return wrappedFn;
}
```

## 总结

思路还是很清晰的，其实大慨有几种方式  
1. 取消Ajax请求  
- 如果基于XMLHttpRquest，可以调用xhr.abort来  
- 
- 如果基于fetch，可以用AbortController  
2. 保留Ajax请求，忽略某些响应结果  
- 基于生成全局id来判断当前请求是否为最新