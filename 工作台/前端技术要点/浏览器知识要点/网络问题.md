## 常见的竞态问题

1. 什么是竟态
2. 通常出现的场景
3. 解决方案有哪些

## 什么是竟态

无法保证异步操作的完成会按照他们开始时同样的顺序

## 出现场景

搜索，分页，选项卡等切换，比如：

-   有一个分页列表，快速地切换第二页，第三页；
-   先后请求 data2 与 data3，分页器显示当前在第三页，并且进入 loading；
-   但由于网络的不确定性，先发出的请求不一定先响应，所以有可能 data3 比 data2 先返回；
-   在 data2 最终返回后，分页器指示当前在第三页，但展示的是第二页的数据。

## 解决方法

### 取消请求

1. 取消请求（xhr.abort, new AbortController(), source.cancel()）
### 注意
#### 旧版axios
在 cancel 时，axios 会在内部调用 promise.reject() 与 xhr.abort()。
```js
axios.get('/xxx', {
  cancelToken: source.token
}).catch(function(err) { 
  if (axios.isCancel(err)) {
    console.log('Request canceled', err.message);
  } else {
    // 处理错误
  }
});
```
所以我们在处理请求错误时，需要判断 error 是否是 cancel 导致的，避免与常规错误一起处理。
#### 新版axios
从 `v0.22.0` 开始，axios 支持以 fetch API 方式的 AbortController 取消请求
```js
const controller = new AbortController();

axios.get('/xxx', {
  signal: controller.signal
}).then(function(response) {
   //...
});

controller.abort() // 取消请求
```

### 可取消的 promise

的 promise，它的 resolve/reject 只能在 new Promise 内部调用，而指令式 promise 支持在 promise 外部手动调用 resolve/reject 等指令。

```js
import { createImperativePromise } from 'awesome-imperative-promise';

const { resolve, reject, cancel } = createImperativePromise(promise);

resolve("some value");
// or
reject(new Error());
// or
cancel();
```


