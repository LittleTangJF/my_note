
##    一、new过程 [地址](https://juejin.cn/post/6844903704663949325)

### 关键技术： Object.create(proto,[propertiesObject])、call/apply、 typeof、target

- 新建空对象，对象[proto]链接到构造函数的prototype
- 新的对象会绑定到函数调用this
- 判断如果函数没有返回对象类型
	- 有就返回该新对象
	- 没有就返回新创建的对象

## 二、call和apply [地址](https://juejin.cn/post/6844903496253177863)

### 关键： this永远指向最后执行他的对象、settimeout是内置函数，this永远指向window

### 如何改变this指向？
- 箭头函数
- call、apply、 bind
- new
- _this = this

1. call: fun.call(thisArg[, arg1[, arg2[, ...]]])
2. apply: fun.apply(thisArg, [argsArray]) ,  thisArg--null 或 undefined 时会自动指向全局对象
3. bind: function.bind(thisArg[, arg1[, arg2[, ...]]])，方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值

## 三、箭头函数

### 和普通函数区别

1. 没有this： 箭头函数不会创建自己的`this`，所以它没有自己的`this`，它只会从自己的作用域链的上一层继承`this`
2. .call()/.apply()/.bind()无法改变箭头函数中this的指向
3. 箭头函数不能作为构造函数使用
4. 箭头函数没有自己的arguments
5.  箭头函数没有原型prototype

## 四、typeof和instanceof

### 注意
最好是用 `typeof` 来判断基本数据类型（包括`symbol`），避免对 null 的判断。

`instanceof` 也可以判断一个实例是否是其父类型或者祖先类型的实例。

## 五、原型链 [地址](https://juejin.cn/post/6934498361475072014)

### 简介

如果我们要找对象的属性或者方法的时候，首先会从自身的属性去找，找不到就往自身原型上找，找不到就继续从原型的原型上找，形成的查找链路就是原型链

### 关键词 ：__proto__  prototype  hasOwnProperty 
 



每个对象都有个隐式原型， 他指向构建出这个对象的构造函数的显式原型prototype



## 六、e.target和e.currentTarget

### 区别
currentTarget始终是监听事件者，而target是事件的真正发出者。

## 七、网络攻击 [在线靶场](https://portswigger.net/web-security/all-labs)

- xss
- scrf

### xss跨站脚本攻击

给网站注入脚本，获取用户信息并伪造用户行为向网站发起自定义攻击请求

#### 类型
- 存储型： 提交恶意代码到数据库
- 反射型：用户点击特定url，通过url参数注入攻击：反射型XSS在搜索框啊，或者是页面跳转啊这些地方
- DOM型：用户点击特定url，通过url参数注入攻击; 是浏览器自身的漏洞

#### 解决

1. 1.  过滤输入的数据，包括  ‘ 、“、<、>、on* 等非法字符
2. HTML实体编码、JS编码，编码后不会执行
3. 1.  设置cookie的HttpOnly属性： 防止客户端脚本通过`document.cookie`属性访问Cookie，

### CSRF 跨站请求伪造

#### 攻击步骤
1. 登录a，保留cookie，再登录b
2. b向a发送请求，浏览器默认携带a的cookie
3. a收到请求，执行了恶意代码，攻击完成

#### 如何防御
- 同源检测：禁止外域访问，referer header
- 请求携带token
- Samesite Cookie属性： 标记同个网站是否可以携带cookie：strict 严格， lax宽松（排除了在a发起或者表单post的情况）a跳转b可以携带
- 


